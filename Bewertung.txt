********************
Kurs-Gesamtnote: 1.3
********************

Aufgabe Jump&Run

Note: 1-

Positiv:
Compiliert & Startet sofort
Sehr cooler Shadow-Shader
Eigene Physik mit Constraints etc
Die Grafiken und der Sound sind schön.
Das Spiel hat Charme!

Kritik & Tips:

Spontane Gedanken beim Spielen:

Esc beendet das Spiel direkt. Meist will man aber nur das Level neustarten?
Deutliches Feedback, wenn man Schaden bekommt fehlt.
Character-Steuerung etwas unintuitiv.

Gesamteindruck:

Das Projekt ist damit sehr ambitioniert schwächelt aber auch an vielen Stellen bei der Umsetzung. Der Code ist teilweise sehr schwer zu lesen was an 14 Parameter langen Constructoren und ähnlichen Strukturschwächen aber auch an der oft willkürlichen Groß/Kleinschreibung liegt.

Tilebasiert. Ja, aber nur in Ansätzen. 

Das GUI startet super ambitioniert mit gesliceten Grafiken doch am Ende gibt es nur einen Button und der hat nicht mal States. Iterative Entwicklung (die ich eigentlich fördern wollte) sieht anders aus.

Die Vorgaben datengetrieben zu arbeiten setzt ihr zwar um. Aber wenn ich die JSONs durchgucke dann wirken sie sehr sperrig. Da ist der Vorteil gegenüber Code (ala GUI.cs) nicht immer zu erkennen. Gleichzeitig seh ich im Code viele Magic-Numbers die sich gut in JSON ausgelagert gemacht hätten.

Apropos GUI.cs ...

public void createInGame()
{
	if (this.inGame.Count == 0)
	{
//INIT
	}
	else
	{
//UPDATE
	}
}

Das liest sich verwirrend und skaliert auch nicht gut. Eine Screenlösung gehört eigentlich zum A&O einer 2D Gameengine. Wenn man es einfach macht einen neuen Screen zu bauen und zwischen diesen zu wechseln, dann verlieren diesbezügliche Ergänzungen ihren Schrecken. Man hat dann ganz schnell ein halbes Dutzend Screens: MainMenu, GameScreen, PauseScreen, GameOver usw… das kommt dem Spiel natürlich zugute und beschleunigt auch die Entwicklung.

Die meisten anderen Projekte machen es mir leichter weil sie qualitativ viel einheitlicher sind. Bei eurem Projekt ist teilweise viel mehr drinn als ich erwartet hätte und andererseits auch viele Stellen die mich enttäuschen. Ein sehr gutes, sehr ambitioniertes Projekt aber wegen der vielen kleinen und nicht so kleinen Schwächen keine glatte 1.


Aufgabe Pong

Note: 1-

Positiv:

Compiliert & Startet sofort! (jetzt wirklich)
Physik!
Physik!
Physik!

Kritik & Tips:

Die Präsentation... naja, wir sind ja alle Programmierer.

Fährt man mit der Maus über das Menü (?) dann flackert das Paddle.

Wenn ihr die Debug-Konsole nicht benutzt, dann macht sie doch einfach aus! Unter Project-Settings/Application Output type von Console Application auf Windows Application umstellen. :)

Sowohl "mass" als auch "inverseMass" im Physics.State vorzuhalten und synchron zu halten ist keine gute Idee. Mass braucht man so gut wie nie (ihr benutzt es auch nicht) und so kann der Getter bei z.B. Circle einfach so implementiert werden:

	public float Mass {
		get { return 1 / current.inverseMass; }
	}

Das ist ja der Vorteil von Properties.

Das Spiel treibt die Physik-Simulation an und rendert die Shapes aber was mir fehlt ist eine Reaktion auf die physikalischen Ereignisse sprich Kollisionen und ähnliches.

Z.B. könnte man bei Kollisionen einen Sound abspielen um das ganze plastischer wirken zu lassen. Wenigstens wenn man mit dem Paddle den Ball reflektiert. Und auch der Test, ob sich der Ball noch im Spielfeld befindet oder gerade die Ziellinie überquert hat ist eigentlich Aufgabe der Physikengine, wenn man denn eine hat.

Sprich, wenn man die Physikengine zum Kernfeature der Aufgabe macht, dann ist der folgende Code eigentlich zu pragmatisch:

	if (ball.COM.X < player.COM.X) {
		ai.score++;
		aiScore.DisplayedString = ai.score.ToString();
		if (soundOn)
		SoundManager.scoreSound.Play();
		Reset();
	}
	if (ball.COM.X > ai.COM.X) {
		player.score++;
		playerScore.DisplayedString = player.score.ToString();
		if (soundOn)
		SoundManager.scoreSound.Play();
		Reset();
	}

Aufgabe Shoot’m Up

Note: 3

Positiv:

Weiter an der Physik-Engine gearbeitet.
Das GUI System sieht auch vielversprechend aus.

Kritik & Tips:

Die Aufgabe, auf einen Satz reduziert, bestand darin ein Spiel zu entwickeln. Und was das angeht, ist die Abgabe leider ziemlich mangelhaft. Naürlich habt ihr immer noch eine beeindruckende Technik auf die Beine gestellt und weiter daran gefeilt aber allerspätestens im nächsten Projekt kommt es dann drauf an diese auch zu nutzen. Jede Engine muss sich daran messen lassen, was man mit ihr anstellen kann.

Persönliche Meinung: Wenn man kein Unit-testing einsetzt, dann ist der einzige Test für die Module die man schreibt das Spiel, dass diesen verwendet - es sollte deshalb keine Methoden geben, die nicht regelmäßig verwendet werden. Und keine Flexibilität die nicht voll ausgenutzt wird oder wenigstens zwischenzeitlich wurde. Diese Art Reality-Check ist wirklich nützlich und leitet einen wie ein roter Faden durch die Entwicklung.

Zum Code:

Verschiedene Movementpatterns sind ne gute Sache. Die Umsetzung deutet Modularität an, verwirrt aber eher als das sie hilft, denn die Collection verfügbarer Movementpatterns wird vom Constructor der Enemy Klasse selbst gefüllt und ist private. Das Dictionary benutzt strings als Keys, die aber auch nur intern verwendet werden. Enums wären dann besser, wenn keine Erweiterbarkeit zur Laufzeit (e.g. data-driven) existiert! Und ein Switch, statt eines Dictionaries, in dem die member direkt aufgerufen werden. KISS.
Sinn würde machen das Movement von außen (durch eine Factory?) zu setzen. Dann kann man - wenn einem eine extra Klasse zu aufwändig ist - durchaus auch nur eine Funktion zuweisen. Aber bitte keine private Methoden eben jener Klasse die man flexibler gestalten will. Wie wär’s mit was ganz dynamisch erstelltem unter Verwendung von Closures?
Gleiches gilt für die verschiedene Waffen.
